/* eslint-disable no-use-before-define */
// Common type definitions for Split Software SDKs based on Javascript
// Project: http://www.split.io/
// Definitions by: Nico Zelaya <https://github.com/NicoZelaya/>

/// <reference types="google.analytics" />

export as namespace SplitIO;
export = SplitIO;

/****** Exposed namespace ******/
/**
 * Types and interfaces for @splitsoftware/splitio package for usage when integrating javascript sdk on typescript apps.
 * For the SDK package information
 * @see {@link https://www.npmjs.com/package/@splitsoftware/splitio}
 */
declare namespace SplitIO {
  /**
   * Reduced version of NodeJS.EventEmitter interface with the minimal methods used by the SDK
   * @see {@link https://nodejs.org/api/events.html}
   */
  interface IEventEmitter {
    addListener(event: string, listener: (...args: any[]) => void): this
    on(event: string, listener: (...args: any[]) => void): this
    once(event: string, listener: (...args: any[]) => void): this
    removeListener(event: string, listener: (...args: any[]) => void): this
    off(event: string, listener: (...args: any[]) => void): this
    removeAllListeners(event?: string): this
    emit(event: string, ...args: any[]): boolean
  }
  /**
   * NodeJS.EventEmitter interface
   * @see {@link https://nodejs.org/api/events.html}
   */
  interface EventEmitter extends IEventEmitter {
    addListener(event: string, listener: (...args: any[]) => void): this;
    on(event: string, listener: (...args: any[]) => void): this;
    once(event: string, listener: (...args: any[]) => void): this;
    removeListener(event: string, listener: (...args: any[]) => void): this;
    off(event: string, listener: (...args: any[]) => void): this;
    removeAllListeners(event?: string): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string): Function[];
    rawListeners(event: string): Function[];
    emit(event: string, ...args: any[]): boolean;
    listenerCount(type: string): number;
    // Added in Node 6...
    prependListener(event: string, listener: (...args: any[]) => void): this;
    prependOnceListener(event: string, listener: (...args: any[]) => void): this;
    eventNames(): Array<string | symbol>;
  }

  /**
   * impression DTO generated by the Sdk client when processing evaluations
   */
  type ImpressionDTO = {
    feature: string,
    keyName: string,
    treatment: string,
    time: number,
    bucketingKey?: string,
    label: string,
    changeNumber: number,
    pt?: number,
  }
  /**
   * @typedef {Object} EventConsts
   * @property {string} SDK_READY The ready event.
   * @property {string} SDK_READY_FROM_CACHE The ready event when fired with cached data.
   * @property {string} SDK_READY_TIMED_OUT The timeout event.
   * @property {string} SDK_UPDATE The update event.
   */
  type EventConsts = {
    SDK_READY: 'init::ready',
    SDK_READY_FROM_CACHE: 'init::cache-ready',
    SDK_READY_TIMED_OUT: 'init::timeout',
    SDK_UPDATE: 'state::update'
  };
  /**
   * SDK Modes.
   * @typedef {string} SDKMode
   */
  type SDKMode = 'standalone' | 'localhost' | 'consumer' | 'consumer_partial';
  /**
   * Storage types.
   * @typedef {string} StorageType
   */
  type StorageType = 'MEMORY' | 'LOCALSTORAGE' | 'REDIS' | 'PLUGGABLE';
  /**
   * Settings interface. This is a representation of the settings the SDK expose, that's why
   * most of it's props are readonly. Only features should be rewritten when localhost mode is active.
   * @interface ISettings
   */
  interface ISettings {
    readonly core: {
      authorizationKey: string,
      key?: SplitKey,
      trafficType?: string,
      labelsEnabled: boolean,
      IPAddressesEnabled?: boolean
    },
    readonly mode: SDKMode,
    readonly scheduler: {
      featuresRefreshRate: number,
      impressionsRefreshRate: number,
      impressionsQueueSize: number,
      /**
       * @deprecated
       */
      metricsRefreshRate?: number,
      telemetryRefreshRate: number,
      segmentsRefreshRate: number,
      offlineRefreshRate: number,
      eventsPushRate: number,
      eventsQueueSize: number,
      pushRetryBackoffBase: number
    },
    readonly startup: {
      readyTimeout: number,
      requestTimeoutBeforeReady: number,
      retriesOnFailureBeforeReady: number,
      eventsFirstPushWindow: number
    },
    readonly storage: {
      prefix: string,
      options: Object,
      type: StorageType
    } | StorageSyncFactory | StorageAsyncFactory,
    readonly urls: {
      events: string,
      sdk: string,
      auth: string,
      streaming: string,
      telemetry: string
    },
    readonly integrations?: BrowserIntegration[] | IntegrationFactory[],
    readonly debug: boolean | LogLevel | ILogger,
    readonly version: string,
    /**
     * Mocked features map.
     */
    features?: MockedFeaturesMap | MockedFeaturesFilePath,
    readonly streamingEnabled: boolean,
    readonly sync: {
      splitFilters: SplitFilter[],
      impressionsMode: ImpressionsMode,
      enabled: boolean,
      localhostMode?: LocalhostFactory,
      __splitFiltersValidation: ISplitFiltersValidation,
    },
    readonly runtime: {
      ip: string | false
      hostname: string | false
    },
    readonly log: ILogger
    readonly impressionListener?: unknown
    /**
     * User consent status if using in browser. Undefined if using in NodeJS.
     */
    readonly userConsent?: ConsentStatus
  }
  /**
   * Log levels.
   * @typedef {string} LogLevel
   */
  type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'NONE';
  /**
   * Logger API
   * @interface ILoggerAPI
   */
  interface ILoggerAPI {
    /**
     * Enables SDK logging to the console.
     * @function enable
     * @returns {void}
     */
    enable(): void,
    /**
     * Disables SDK logging.
     * @function disable
     * @returns {void}
     */
    disable(): void,
    /**
     * Sets a log level for the SDK logs.
     * @function setLogLevel
     * @returns {void}
     */
    setLogLevel(logLevel: LogLevel): void,
    /**
     * Log level constants. Use this to pass them to setLogLevel function.
     */
    LogLevel: {
      [level in LogLevel]: LogLevel
    }
  }
  /**
   * User consent API
   * @interface IUserConsentAPI
   */
  interface IUserConsentAPI {
    /**
     * Set or update the user consent status. Possible values are `true` and `false`, which represent user consent `'GRANTED'` and `'DECLINED'` respectively.
     * - `true ('GRANTED')`: the user has granted consent for tracking events and impressions. The SDK will send them to Split cloud.
     * - `false ('DECLINED')`: the user has declined consent for tracking events and impressions. The SDK will not send them to Split cloud.
     *
     * NOTE: calling this method updates the user consent at a factory level, affecting all clients of the same factory.
     *
     * @function setStatus
     * @param {boolean} userConsent The user consent status, true for 'GRANTED' and false for 'DECLINED'.
     * @returns {boolean} Whether the provided param is a valid value (i.e., a boolean value) or not.
     */
    setStatus(userConsent: boolean): boolean;
    /**
     * Get the user consent status.
     *
     * @function getStatus
     * @returns {ConsentStatus} The user consent status.
     */
    getStatus(): ConsentStatus;
    /**
     * Consent status constants. Use this to compare with the getStatus function result.
     */
    Status: {
      [status in ConsentStatus]: ConsentStatus
    }
  }
  /**
   * Common settings between Browser and NodeJS settings interface.
   * @interface ISharedSettings
   */
  interface ISharedSettings {
    /**
     * SDK Core settings.
     * @property {Object} core
     */
    core: {
      /**
       * Your API key. More information: @see {@link https://help.split.io/hc/en-us/articles/360019916211-API-keys}
       * @property {string} authorizationKey
       */
      authorizationKey: string,
      /**
       * Disable labels from being sent to Split backend. Labels may contain sensitive information.
       * This configuration is applicable if the SDK is running in "standalone" or "partial consumer" mode.
       * @property {boolean} labelsEnabled
       * @default true
       */
      labelsEnabled?: boolean
    },
    /**
     * The SDK mode. Possible values are "standalone", which is the default when using a synchronous storage, like 'MEMORY' and 'LOCALSTORAGE',
     * and "consumer", which must be set when using an asynchronous storage, like 'REDIS'. For "localhost" mode, use "localhost" as authorizationKey.
     * @property {SDKMode} mode
     * @default standalone
     */
    mode?: SDKMode,
    /**
     * The impression listener, which is optional. Whatever you provide here needs to comply with the IImpressionListener interface,
     * which will check for the logImpression method.
     * @property {IImpressionListener} impressionListener
     * @default undefined
     */
    impressionListener?: IImpressionListener,
    /**
     * Boolean flag to enable the streaming service as default synchronization mechanism. In the event of any issue with streaming,
     * the SDK would fallback to the polling mechanism. If false, the SDK would poll for changes as usual without attempting to use streaming.
     * This configuration is applicable if the SDK is running in "standalone" mode.
     * @property {boolean} streamingEnabled
     * @default true
     */
    streamingEnabled?: boolean,
    /**
     * SDK synchronization settings.
     * @property {Object} sync
     */
    sync?: {
      /**
       * List of Split filters. These filters are used to fetch a subset of the Splits definitions in your environment, in order to reduce the delay of the SDK to be ready.
       * This configuration is applicable if the SDK is running in "standalone" mode.
       *
       * At the moment, two types of split filters are supported: by name and by prefix.
       *
       * Example:
       *  `splitFilter: [
       *    { type: 'byName', values: ['my_split_1', 'my_split_2'] }, // will fetch splits named 'my_split_1' and 'my_split_2'
       *    { type: 'byPrefix', values: ['testing'] } // will fetch splits whose names start with 'testing__' prefix
       *  ]`
       * @property {SplitFilter[]} splitFilters
       */
      splitFilters?: SplitFilter[]
      /**
       * Impressions Collection Mode. Option to determine how impressions are going to be sent to Split Servers.
       * Possible values are 'DEBUG' and 'OPTIMIZED'.
       * - DEBUG: will send all the impressions generated (recommended only for debugging purposes).
       * - OPTIMIZED: will send unique impressions to Split Servers avoiding a considerable amount of traffic that duplicated impressions could generate.
       * @property {string} impressionsMode
       * @default 'OPTIMIZED'
       */
      impressionsMode?: ImpressionsMode,
      /**
       * Controls the SDK continuous synchronization flags.
       *
       * When `true` a running SDK will process rollout plan updates performed on the UI (default).
       * When false it'll just fetch all data upon init.
       * This configuration is applicable if the SDK is running in "standalone" mode.
       *
       * @property {boolean} enabled
       * @default true
       */
      enabled?: boolean
    },
    /**
     * List of URLs that the SDK will use as base for it's synchronization functionalities.
     * This configuration is applicable if the SDK is running in "standalone" or "partial consumer" mode.
     * Do not change these settings unless you're working an advanced use case, like connecting to the Split proxy.
     * @property {Object} urls
     */
    urls?: UrlSettings,
  }
  // @TODO Should extends IEventEmitter for React Native and JS Browser SDK
  /**
   * Common API for entities that expose status handlers.
   * @interface IStatusInterface
   * @extends IEventEmitter
   */
  interface IStatusInterface extends IEventEmitter {
    /**
     * Constant object containing the SDK events for you to use.
     * @property {EventConsts} Event
     */
    Event: EventConsts,
    /**
     * Returns a promise that will be resolved once the SDK has finished loading (SDK_READY event emitted) or rejected if the SDK has timedout (SDK_READY_TIMED_OUT event emitted).
     * As it's meant to provide similar flexibility to the event approach, given that the SDK might be eventually ready after a timeout event, calling the `ready` method after the
     * SDK had timed out will return a new promise that should eventually resolve if the SDK gets ready.
     *
     * Caveats: the method was designed to avoid an unhandled Promise rejection if the rejection case is not handled, so that `onRejected` handler is optional when using promises.
     * However, when using async/await syntax, the rejection should be explicitly propagated like in the following example:
     * ```
     * try {
     *   await client.ready().catch((e) => { throw e; });
     *   // SDK is ready
     * } catch(e) {
     *   // SDK has timedout
     * }
     * ```
     *
     * @function ready
     * @returns {Promise<void>}
     */
    ready(): Promise<void>
  }
  /**
   * Common definitions between clients for different environments interface.
   * @interface IBasicClient
   * @extends IStatusInterface
   */
  interface IBasicClient extends IStatusInterface {
    /**
     * Destroy the client instance.
     * @function destroy
     * @returns {Promise<void>}
     */
    destroy(): Promise<void>
  }

  /**
   * Split treatment value, returned by getTreatment.
   * @typedef {string} Treatment
   */
  type Treatment = string;
  /**
   * Split treatment promise that will resolve to actual treatment value.
   * @typedef {Promise<string>} AsyncTreatment
   */
  type AsyncTreatment = Promise<string>;
  /**
   * An object with the treatments for a bulk of splits, returned by getTreatments. For example:
   *   {
   *     feature1: 'on',
   *     feature2: 'off
   *   }
   * @typedef {Object.<Treatment>} Treatments
   */
  type Treatments = {
    [featureName: string]: Treatment
  };
  /**
   * Split treatments promise that will resolve to the actual Treatments object.
   * @typedef {Promise<Treatments>} AsyncTreatments
   */
  type AsyncTreatments = Promise<Treatments>;
  /**
   * Split evaluation result with treatment and configuration, returned by getTreatmentWithConfig.
   * @typedef {Object} TreatmentWithConfig
   * @property {string} treatment The treatment result
   * @property {string | null} config The stringified version of the JSON config defined for that treatment, null if there is no config for the resulting treatment.
   */
  type TreatmentWithConfig = {
    treatment: string,
    config: string | null
  };
  /**
   * Split treatment promise that will resolve to actual treatment with config value.
   * @typedef {Promise<TreatmentWithConfig>} AsyncTreatmentWithConfig
   */
  type AsyncTreatmentWithConfig = Promise<TreatmentWithConfig>;
  /**
   * An object with the treatments with configs for a bulk of splits, returned by getTreatmentsWithConfig.
   * Each existing configuration is a stringified version of the JSON you defined on the Split web console. For example:
   *   {
   *     feature1: { treatment: 'on', config: null }
   *     feature2: { treatment: 'off', config: '{"bannerText":"Click here."}' }
   *   }
   * @typedef {Object.<TreatmentWithConfig>} Treatments
   */
  type TreatmentsWithConfig = {
    [featureName: string]: TreatmentWithConfig
  };
  /**
   * Split treatments promise that will resolve to the actual TreatmentsWithConfig object.
   * @typedef {Promise<TreatmentsWithConfig>} AsyncTreatmentsWithConfig
   */
  type AsyncTreatmentsWithConfig = Promise<TreatmentsWithConfig>;
  /**
   * Possible Split SDK events.
   * @typedef {string} Event
   */
  type Event = 'init::timeout' | 'init::ready' | 'init::cache-ready' | 'state::update';
  /**
   * Split attributes should be on object with values of type string, boolean, number (dates should be sent as millis since epoch) or array of strings or numbers.
   * @typedef {Object.<AttributeType>} Attributes
   * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#attribute-syntax}
   */
  type Attributes = {
    [attributeName: string]: AttributeType
  };
  /**
   * Type of an attribute value
   * @typedef {string | number | boolean | Array<string | number>} AttributeType
   */
  type AttributeType = string | number | boolean | Array<string | number>;
  /**
   * Split properties should be an object with values of type string, number, boolean or null. Size limit of ~31kb.
   * @typedef {Object.<number, string, boolean, null>} Properties
   * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#track
   */
  type Properties = {
    [propertyName: string]: string | number | boolean | null
  };
  /**
   * The SplitKey object format.
   * @typedef {Object.<string>} SplitKeyObject
   */
  type SplitKeyObject = {
    matchingKey: string,
    bucketingKey: string
  };
  /**
   * The customer identifier. Could be a SplitKeyObject or a string.
   * @typedef {SplitKeyObject|string} SplitKey
   */
  type SplitKey = SplitKeyObject | string;
  /**
   * Path to file with mocked features (for node).
   * @typedef {string} MockedFeaturesFilePath
   */
  type MockedFeaturesFilePath = string;
  /**
   * Object with mocked features mapping (for browser). We need to specify the featureName as key, and the mocked treatment as value.
   * @typedef {Object} MockedFeaturesMap
   */
  type MockedFeaturesMap = {
    [featureName: string]: string | TreatmentWithConfig
  };
  /**
   * Localhost types.
   * @typedef {string} LocalhostType
   */
  type LocalhostType = 'LocalhostFromObject'
  /**
   * Object with information about an impression. It contains the generated impression DTO as well as
   * complementary information around where and how it was generated in that way.
   * @typedef {Object} ImpressionData
   */
  type ImpressionData = {
    impression: ImpressionDTO,
    attributes?: Attributes,
    ip: string | false,
    hostname: string | false,
    sdkLanguageVersion: string
  };
  /**
   * Data corresponding to one Split view.
   * @typedef {Object} SplitView
   */
  type SplitView = {
    /**
     * The name of the split.
     * @property {string} name
     */
    name: string,
    /**
     * The traffic type of the split.
     * @property {string} trafficType
     */
    trafficType: string,
    /**
     * Whether the split is killed or not.
     * @property {boolean} killed
     */
    killed: boolean,
    /**
     * The list of treatments available for the split.
     * @property {Array<string>} treatments
     */
    treatments: Array<string>,
    /**
     * Current change number of the split.
     * @property {number} changeNumber
     */
    changeNumber: number,
    /**
     * Map of configurations per treatment.
     * Each existing configuration is a stringified version of the JSON you defined on the Split web console.
     * @property {Object.<string>} configs
     */
    configs: {
      [treatmentName: string]: string
    }
  };
  /**
   * A promise that will be resolved with that SplitView or null if the split is not found.
   * @typedef {Promise<SplitView | null>} SplitView
   */
  type SplitViewAsync = Promise<SplitView | null>;
  /**
   * An array containing the SplitView elements.
   */
  type SplitViews = Array<SplitView>;
  /**
   * A promise that will be resolved with an SplitViews array.
   * @typedef {Promise<SplitViews>} SplitViewsAsync
   */
  type SplitViewsAsync = Promise<SplitViews>;
  /**
   * An array of split names.
   * @typedef {Array<string>} SplitNames
   */
  type SplitNames = Array<string>;
  /**
   * A promise that will be resolved with an array of split names.
   * @typedef {Promise<SplitNames>} SplitNamesAsync
   */
  type SplitNamesAsync = Promise<SplitNames>;
  /**
   * Synchronous storage valid types for NodeJS.
   * @typedef {string} NodeSyncStorage
   */
  type NodeSyncStorage = 'MEMORY';
  /**
   * Asynchronous storages valid types for NodeJS.
   * @typedef {string} NodeAsyncStorage
   */
  type NodeAsyncStorage = 'REDIS';
  /**
   * Storage valid types for the browser.
   * @typedef {string} BrowserStorage
   */
  type BrowserStorage = 'MEMORY' | 'LOCALSTORAGE';
  /**
   * Storage for synchronous (standalone) SDK.
   * Its interface details are not part of the public API.
   */
  type StorageSync = any;
  /**
   * Storage builder for synchronous (standalone) SDK.
   * By returning undefined, the SDK will use the default IN MEMORY storage.
   * Input parameter details are not part of the public API.
   */
  type StorageSyncFactory = {
    readonly type: StorageType
    (params: any): (StorageSync | undefined)
  }
  /**
   * Configuration params for `InLocalStorage`
   */
  type InLocalStorageOptions = {
    /**
     * Optional prefix to prevent any kind of data collision when having multiple factories using the same storage type.
     * @property {string} prefix
     * @default SPLITIO
     */
    prefix?: string
  }
  /**
   * Storage for asynchronous (consumer) SDK.
   * Its interface details are not part of the public API.
   */
  type StorageAsync = any
  /**
   * Storage builder for asynchronous (consumer) SDK.
   * Input parameter details are not part of the public API.
   */
  type StorageAsyncFactory = {
    readonly type: StorageType
    (params: any): StorageAsync
  }
  /**
   * Configuration params for `PluggableStorage`
   */
  type PluggableStorageOptions = {
    /**
     * Optional prefix to prevent any kind of data collision when having multiple factories using the same storage wrapper.
     * @property {string} prefix
     * @default SPLITIO
     */
    prefix?: string,
    /**
     * Storage wrapper.
     * @property {Object} wrapper
     */
    wrapper: Object
  }
  /**
   * Localhost mode factory.
   * Its interface details are not part of the public API.
   */
  type LocalhostFactory = {
    readonly type: LocalhostType
    (params: any): any
  }
  /**
   * Impression listener interface. This is the interface that needs to be implemented
   * by the element you provide to the SDK as impression listener.
   * @interface IImpressionListener
   * @see {@link https://help.split.io/hc/en-us/articles/360020564931-Node-js-SDK#listener}
   */
  interface IImpressionListener {
    logImpression(data: ImpressionData): void
  }
  /**
   * SDK integration instance.
   * Its interface details are not part of the public API.
   */
  type Integration = any;
  /**
   * SDK integration factory.
   * By returning an integration, the SDK will queue events and impressions into it.
   * Input parameter details are not part of the public API.
   */
  type IntegrationFactory = {
    readonly type: string
    (params: any): (Integration | void)
  }
  /**
   * A pair of user key and it's trafficType, required for tracking valid Split events.
   * @typedef {Object} Identity
   * @property {string} key The user key.
   * @property {string} trafficType The key traffic type.
   */
  type Identity = {
    key: string;
    trafficType: string;
  };
  /**
   * Object with information about a Split event.
   * @typedef {Object} EventData
   */
  type EventData = {
    eventTypeId: string;
    value?: number;
    properties?: Properties;
    trafficTypeName?: string;
    key?: string;
    timestamp?: number;
  };
  /**
   * Enable 'Google Analytics to Split' integration, to track Google Analytics hits as Split events.
   *
   * @see {@link https://help.split.io/hc/en-us/articles/360040838752#google-analytics-to-split}
   */
  interface IGoogleAnalyticsToSplitConfig extends GoogleAnalyticsToSplitOptions {
    type: 'GOOGLE_ANALYTICS_TO_SPLIT',
  }
  /**
   * Configuration params for 'Google Analytics to Split' integration plugin, to track Google Analytics hits as Split events.
   *
   * @see {@link https://help.split.io/hc/en-us/articles/360040838752#google-analytics-to-split}
   */
  interface GoogleAnalyticsToSplitOptions {
    /**
     * Optional flag to filter GA hits from being tracked as Split events.
     * @property {boolean} hits
     * @default true
     */
    hits?: boolean,
    /**
     * Optional predicate used to define a custom filter for tracking GA hits as Split events.
     * For example, the following filter allows to track only 'event' hits:
     *  `(model) => model.get('hitType') === 'event'`
     * By default, all hits are tracked as Split events.
     */
    filter?: (model: UniversalAnalytics.Model) => boolean,
    /**
     * Optional function useful when you need to modify the Split event before tracking it.
     * This function is invoked with two arguments:
     * 1. the GA model object representing the hit.
     * 2. the default format of the mapped Split event instance.
     * The return value must be a Split event, that can be the second argument or a new object.
     *
     * For example, the following mapper adds a custom property to events:
     *  `(model, defaultMapping) => {
     *      defaultMapping.properties.someProperty = SOME_VALUE;
     *      return defaultMapping;
     *  }`
     */
    mapper?: (model: UniversalAnalytics.Model, defaultMapping: EventData) => EventData,
    /**
     * Optional prefix for EventTypeId, to prevent any kind of data collision between events.
     * @property {string} prefix
     * @default 'ga'
     */
    prefix?: string,
    /**
     * List of Split identities (key & traffic type pairs) used to track events.
     * If not provided, events are sent using the key and traffic type provided at SDK config.
     */
    identities?: Identity[],
    /**
     * Optional flag to log an error if the `auto-require` script is not detected.
     * The auto-require script automatically requires the `splitTracker` plugin for created trackers,
     * and should be placed right after your Google Analytics, Google Tag Manager or gtag.js script tag.
     *
     * @see {@link https://help.split.io/hc/en-us/articles/360040838752#set-up-with-gtm-and-gtag.js}
     *
     * @property {boolean} autoRequire
     * @default false
     */
    autoRequire?: boolean,
  }
  /**
   * Object representing the data sent by Split (events and impressions).
   * @typedef {Object} IntegrationData
   * @property {string} type The type of Split data, either 'IMPRESSION' or 'EVENT'.
   * @property {ImpressionData | EventData} payload The data instance itself.
   */
  type IntegrationData = { type: 'IMPRESSION', payload: ImpressionData } | { type: 'EVENT', payload: EventData };
  /**
   * Enable 'Split to Google Analytics' integration, to track Split impressions and events as Google Analytics hits.
   *
   * @see {@link https://help.split.io/hc/en-us/articles/360040838752#split-to-google-analytics}
   */
  interface ISplitToGoogleAnalyticsConfig extends SplitToGoogleAnalyticsOptions {
    type: 'SPLIT_TO_GOOGLE_ANALYTICS',
  }
  /**
   * Configuration params for 'Split to Google Analytics' integration plugin, to track Split impressions and events as Google Analytics hits.
   *
   * @see {@link https://help.split.io/hc/en-us/articles/360040838752#split-to-google-analytics}
   */
  interface SplitToGoogleAnalyticsOptions {
    /**
     * Optional flag to filter Split impressions from being tracked as GA hits.
     * @property {boolean} impressions
     * @default true
     */
    impressions?: boolean,
    /**
     * Optional flag to filter Split events from being tracked as GA hits.
     * @property {boolean} events
     * @default true
     */
    events?: boolean,
    /**
     * Optional predicate used to define a custom filter for tracking Split data (events and impressions) as GA hits.
     * For example, the following filter allows to track only impressions, equivalent to setting events to false:
     *  `(data) => data.type === 'IMPRESSION'`
     */
    filter?: (data: IntegrationData) => boolean,
    /**
     * Optional function useful when you need to modify the GA hit before sending it.
     * This function is invoked with two arguments:
     * 1. the input data (Split event or impression).
     * 2. the default format of the mapped FieldsObject instance (GA hit).
     * The return value must be a FieldsObject, that can be the second argument or a new object.
     *
     * For example, the following mapper adds a custom dimension to hits:
     *  `(data, defaultMapping) => {
     *      defaultMapping.dimension1 = SOME_VALUE;
     *      return defaultMapping;
     *  }`
     *
     * Default FieldsObject instance for data.type === 'IMPRESSION':
     *  `{
     *    hitType: 'event',
     *    eventCategory: 'split-impression',
     *    eventAction: 'Evaluate ' + data.payload.impression.feature,
     *    eventLabel: 'Treatment: ' + data.payload.impression.treatment + '. Targeting rule: ' + data.payload.impression.label + '.',
     *    nonInteraction: true,
     *  }`
     * Default FieldsObject instance for data.type === 'EVENT':
     *  `{
     *    hitType: 'event',
     *    eventCategory: 'split-event',
     *    eventAction: data.payload.eventTypeId,
     *    eventValue: data.payload.value,
     *    nonInteraction: true,
     *  }`
     */
    mapper?: (data: IntegrationData, defaultMapping: UniversalAnalytics.FieldsObject) => UniversalAnalytics.FieldsObject,
    /**
     * List of tracker names to send the hit. An empty string represents the default tracker.
     * If not provided, hits are only sent to default tracker.
     */
    trackerNames?: string[],
  }
  /**
   * Available URL settings for the SDKs.
   */
  type UrlSettings = {
    /**
     * String property to override the base URL where the SDK will get feature flagging related data like a Split rollout plan or segments information.
     * @property {string} sdk
     * @default 'https://sdk.split.io/api'
     */
    sdk?: string,
    /**
     * String property to override the base URL where the SDK will post event-related information like impressions.
     * @property {string} events
     * @default 'https://events.split.io/api'
     */
    events?: string,
    /**
     * String property to override the base URL where the SDK will get authorization tokens to be used with functionality that requires it, like streaming.
     * @property {string} auth
     * @default 'https://auth.split.io/api'
     */
    auth?: string,
    /**
     * String property to override the base URL where the SDK will connect to receive streaming updates.
     * @property {string} streaming
     * @default 'https://streaming.split.io'
     */
    streaming?: string,
    /**
     * String property to override the base URL where the SDK will post telemetry data.
     * @property {string} telemetry
     * @default 'https://telemetry.split.io/api'
     */
    telemetry?: string
  };

  /**
   * Available integration options for the browser
   */
  type BrowserIntegration = ISplitToGoogleAnalyticsConfig | IGoogleAnalyticsToSplitConfig;
  /**
   * SplitFilter type.
   * @typedef {string} SplitFilterType
   */
  type SplitFilterType = 'byName' | 'byPrefix';
  /**
   * Defines a split filter, described by a type and list of values.
   */
  interface SplitFilter {
    /**
     * Type of the filter.
     * @property {SplitFilterType} type
     */
    type: SplitFilterType,
    /**
     * List of values: split names for 'byName' filter type, and split prefixes for 'byPrefix' type.
     * @property {string[]} values
     */
    values: string[],
  }
  type ISplitFiltersValidation = {
    queryString: string | null,
    groupedFilters: Record<SplitFilterType, string[]>,
    validFilters: SplitFilter[]
  };
  /**
  * ImpressionsMode type
  * @typedef {string} ImpressionsMode
  */
  type ImpressionsMode = 'OPTIMIZED' | 'DEBUG';
  /**
   * User consent status.
   * @typedef {string} ConsentStatus
   */
  type ConsentStatus = 'GRANTED' | 'DECLINED' | 'UNKNOWN';
  /**
   * Logger
   * Its interface details are not part of the public API. It shouldn't be used directly.
   * @interface ILogger
   */
  interface ILogger {
    setLogLevel(logLevel: LogLevel): void
    debug(msg: any): void
    debug(msg: string | number, args?: any[]): void
    info(msg: any): void
    info(msg: string | number, args?: any[]): void
    warn(msg: any): void
    warn(msg: string | number, args?: any[]): void
    error(msg: any): void
    error(msg: string | number, args?: any[]): void
  }
  /**
   * Common settings interface with non-pluggable API (JS SDK).
   * @interface IStaticSettings
   * @extends ISharedSettings
   */
  interface IStaticSettings {
    /**
     * Whether the logger should be enabled or disabled by default.
     * @property {Boolean} debug
     * @default false
     */
    debug?: boolean | LogLevel,
  }
  /**
   * Common settings interface with pluggable API (JS Browser and React Native SDKs).
   * @interface IPluggableSettings
   * @extends ISharedSettings
   */
  interface IPluggableSettings {
    /**
     * Boolean value to indicate whether the logger should be enabled or disabled by default, or a log level string or a Logger object.
     * Passing a logger object is required to get descriptive log messages. Otherwise most logs will print with message codes.
     * @see {@link https://help.split.io/hc/en-us/articles/360058730852-Browser-SDK#logging}
     *
     * Examples:
     * ```typescript
     * config.debug = true
     * config.debug = 'WARN'
     * config.debug = ErrorLogger()
     * ```
     * @property {boolean | LogLevel | ILogger} debug
     * @default false
     */
    debug?: boolean | LogLevel | ILogger,
    /**
     * Defines an optional list of factory functions used to instantiate SDK integrations.
     *
     * Example:
     * ```typescript
     * SplitFactory({
     *   ...
     *   integrations: [SplitToGoogleAnalytics(), GoogleAnalyticsToSplit()]
     * })
     * ```
     * @property {Object} integrations
     */
    integrations?: IntegrationFactory[],
  }
  /**
   * Common settings interface for SDK instances on NodeJS.
   * @interface IServerSideSharedSettings
   * @extends ISharedSettings
   */
  interface IServerSideSharedSettings extends ISharedSettings {
    /**
     * SDK Core settings for NodeJS.
     * @property {Object} core
     */
    core: ISharedSettings['core'] & {
      /**
       * Disable machine IP and Name from being sent to Split backend.
       * @property {boolean} IPAddressesEnabled
       * @default true
       */
      IPAddressesEnabled?: boolean
    },
    /**
     * Mocked features file path. For testing purposses only. For using this you should specify "localhost" as authorizationKey on core settings.
     * @see {@link https://help.split.io/hc/en-us/articles/360020564931-Node-js-SDK#localhost-mode}
     * @property {MockedFeaturesFilePath} features
     * @default $HOME/.split
     */
    features?: MockedFeaturesFilePath,
    /**
     * SDK Startup settings for NodeJS.
     * @property {Object} startup
     */
    startup?: {
      /**
       * Maximum amount of time used before notify a timeout.
       * @property {number} readyTimeout
       * @default 15
       */
      readyTimeout?: number,
      /**
       * Time to wait for a request before the SDK is ready. If this time expires, JS Sdk will retry 'retriesOnFailureBeforeReady' times before notifying its failure to be 'ready'.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} requestTimeoutBeforeReady
       * @default 15
       */
      requestTimeoutBeforeReady?: number,
      /**
       * How many quick retries we will do while starting up the SDK.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} retriesOnFailureBeforeReady
       * @default 1
       */
      retriesOnFailureBeforeReady?: number,
      /**
       * For SDK posts the queued events data in bulks with a given rate, but the first push window is defined separately,
       * to better control on browsers. This number defines that window before the first events push.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsFirstPushWindow
       * @default 0
       */
      eventsFirstPushWindow?: number,
    },
    /**
     * SDK scheduler settings.
     * @property {Object} scheduler
     */
    scheduler?: {
      /**
       * The SDK polls Split servers for changes to feature roll-out plans. This parameter controls this polling period in seconds.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} featuresRefreshRate
       * @default 5
       */
      featuresRefreshRate?: number,
      /**
       * The SDK polls Split servers for changes to segment definitions. This parameter controls this polling period in seconds.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} segmentsRefreshRate
       * @default 60
       */
      segmentsRefreshRate?: number,
      /**
       * The SDK sends information on who got what treatment at what time back to Split servers to power analytics. This parameter controls how often this data is sent to Split servers. The parameter should be in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} impressionsRefreshRate
       * @default 300
       */
      impressionsRefreshRate?: number,
      /**
       * The maximum number of impression items we want to queue. If we queue more values, it will trigger a flush and reset the timer.
       * If you use a 0 here, the queue will have no maximum size.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} impressionsQueueSize
       * @default 30000
       */
      impressionsQueueSize?: number,
      /**
       * The SDK sends diagnostic metrics to Split servers. This parameters controls this metric flush period in seconds.
       * @property {number} metricsRefreshRate
       * @default 120
       * @deprecated This parameter is ignored now. Use `telemetryRefreshRate` instead.
       */
      metricsRefreshRate?: number,
      /**
       * The SDK sends diagnostic metrics to Split servers. This parameters controls this metric flush period in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} telemetryRefreshRate
       * @default 3600
       */
      telemetryRefreshRate?: number,
      /**
       * The SDK posts the queued events data in bulks. This parameter controls the posting rate in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsPushRate
       * @default 60
       */
      eventsPushRate?: number,
      /**
       * The maximum number of event items we want to queue. If we queue more values, it will trigger a flush and reset the timer.
       * If you use a 0 here, the queue will have no maximum size.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsQueueSize
       * @default 500
       */
      eventsQueueSize?: number,
      /**
       * For mocking/testing only. The SDK will refresh the features mocked data when mode is set to "localhost" by defining the key.
       * For more information @see {@link https://help.split.io/hc/en-us/articles/360020564931-Node-js-SDK#localhost-mode}
       * @property {number} offlineRefreshRate
       * @default 15
       */
      offlineRefreshRate?: number
      /**
       * When using streaming mode, seconds to wait before re attempting to connect for push notifications.
       * Next attempts follow intervals in power of two: base seconds, base x 2 seconds, base x 4 seconds, ...
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} pushRetryBackoffBase
       * @default 1
       */
      pushRetryBackoffBase?: number,
    },
  }
  /**
   * Common settings interface for SDK instances created on client-side (Browser & React Native).
   * @interface IClientSideSharedSettings
   * @extends ISharedSettings
   */
  interface IClientSideSharedSettings extends ISharedSettings {
    /**
     * SDK Core settings for client-side.
     * @property {Object} core
     */
    core: ISharedSettings['core'] & {
      /**
       * Customer identifier. Whatever this means to you. @see {@link https://help.split.io/hc/en-us/articles/360019916311-Traffic-type}
       * @property {SplitKey} key
       */
      key: SplitKey,
    },
    /**
     * Mocked features map. For testing purposses only. For using this you should specify "localhost" as authorizationKey on core settings.
     * @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#localhost-mode}
     */
    features?: MockedFeaturesMap,
    /**
     * SDK Startup settings for client-side.
     * @property {Object} startup
     */
    startup?: {
      /**
       * Maximum amount of time used before notify a timeout.
       * @property {number} readyTimeout
       * @default 1.5
       */
      readyTimeout?: number,
      /**
       * Time to wait for a request before the SDK is ready. If this time expires, JS Sdk will retry 'retriesOnFailureBeforeReady' times before notifying its failure to be 'ready'.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} requestTimeoutBeforeReady
       * @default 1.5
       */
      requestTimeoutBeforeReady?: number,
      /**
       * How many quick retries we will do while starting up the SDK.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} retriesOnFailureBeforeReady
       * @default 1
       */
      retriesOnFailureBeforeReady?: number,
      /**
       * For SDK posts the queued events data in bulks with a given rate, but the first push window is defined separately,
       * to better control on browsers. This number defines that window before the first events push.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsFirstPushWindow
       * @default 10
       */
      eventsFirstPushWindow?: number,
    },
    /**
     * SDK scheduler settings.
     * @property {Object} scheduler
     */
    scheduler?: {
      /**
       * The SDK polls Split servers for changes to feature roll-out plans. This parameter controls this polling period in seconds.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} featuresRefreshRate
       * @default 30
       */
      featuresRefreshRate?: number,
      /**
       * The SDK polls Split servers for changes to segment definitions. This parameter controls this polling period in seconds.
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} segmentsRefreshRate
       * @default 60
       */
      segmentsRefreshRate?: number,
      /**
       * The SDK sends information on who got what treatment at what time back to Split servers to power analytics. This parameter controls how often this data is sent to Split servers. The parameter should be in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} impressionsRefreshRate
       * @default 60
       */
      impressionsRefreshRate?: number,
      /**
       * The maximum number of impression items we want to queue. If we queue more values, it will trigger a flush and reset the timer.
       * If you use a 0 here, the queue will have no maximum size.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} impressionsQueueSize
       * @default 30000
       */
      impressionsQueueSize?: number,
      /**
       * The SDK sends diagnostic metrics to Split servers. This parameters controls this metric flush period in seconds.
       * @property {number} metricsRefreshRate
       * @default 120
       * @deprecated This parameter is ignored now. Use `telemetryRefreshRate` instead.
       */
      metricsRefreshRate?: number,
      /**
       * The SDK sends diagnostic metrics to Split servers. This parameters controls this metric flush period in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} telemetryRefreshRate
       * @default 3600
       */
      telemetryRefreshRate?: number,
      /**
       * The SDK posts the queued events data in bulks. This parameter controls the posting rate in seconds.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsPushRate
       * @default 60
       */
      eventsPushRate?: number,
      /**
       * The maximum number of event items we want to queue. If we queue more values, it will trigger a flush and reset the timer.
       * If you use a 0 here, the queue will have no maximum size.
       *
       * NOTE: this param is ignored in "consumer" mode.
       * @property {number} eventsQueueSize
       * @default 500
       */
      eventsQueueSize?: number,
      /**
       * For mocking/testing only. The SDK will refresh the features mocked data when mode is set to "localhost" by defining the key.
       * For more information @see {@link https://help.split.io/hc/en-us/articles/360020448791-JavaScript-SDK#localhost-mode}
       * @property {number} offlineRefreshRate
       * @default 15
       */
      offlineRefreshRate?: number,
      /**
       * When using streaming, seconds to wait before re attempting to connect for push notifications.
       * Next attempts follow intervals in power of two: base seconds, base x 2 seconds, base x 4 seconds, ...
       *
       * NOTE: this param is applicable in "standalone" mode.
       * @property {number} pushRetryBackoffBase
       * @default 1
       */
      pushRetryBackoffBase?: number,
    }
    /**
     * User consent status. Possible values are `'GRANTED'`, which is the default, `'DECLINED'` or `'UNKNOWN'`.
     * - `'GRANTED'`: the user grants consent for tracking events and impressions. The SDK sends them to Split cloud.
     * - `'DECLINED'`: the user declines consent for tracking events and impressions. The SDK does not send them to Split cloud.
     * - `'UNKNOWN'`: the user neither grants nor declines consent for tracking events and impressions. The SDK tracks them in its internal storage, and eventually either sends
     * them or not if the consent status is updated to 'GRANTED' or 'DECLINED' respectively. The status can be updated at any time with the `UserConsent.setStatus` factory method.
     *
     * @typedef {string} userConsent
     * @default 'GRANTED'
     */
    userConsent?: ConsentStatus
  }
  /**
   * Common definitions between SDK instances for different environments interface.
   * @interface IBasicSDK
   */
  interface IBasicSDK<TClient, TManager> {
    /**
     * Returns the default client instance of the SDK.
     * @function client
     * @returns {IClient} The client instance.
     */
    client(): TClient,
    /**
     * Returns a manager instance of the SDK to explore available information.
     * @function manager
     * @returns {IManager} The manager instance.
     */
    manager(): TManager
    /**
     * Current settings of the SDK instance.
     * @property settings
     */
    settings: ISettings,
    /**
     * Logger API.
     * @property Logger
     */
    Logger: ILoggerAPI
  }
  /**
   * Common interface between client-side SDK instances.
   * @interface ISDKCs
   */
  interface ISDKWithUserConsent<TClient, TManager> extends IBasicSDK<TClient, TManager> {
    /**
     * User consent API.
     * @property UserConsent
     */
    UserConsent: IUserConsentAPI
  }
  /**
   * This represents the interface for the Client instance with synchronous method calls and server-side API, where we don't have only one key.
   * @interface IClient
   * @extends IBasicClient
   */
  interface IClientSS extends IBasicClient {
    /**
     * Returns a Treatment value, which is the treatment string for the given feature.
     * @function getTreatment
     * @param {string} key - The string key representing the consumer.
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatment} The treatment string.
     */
    getTreatment(key: SplitKey, splitName: string, attributes?: Attributes): Treatment,
    /**
     * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.
     * @function getTreatmentWithConfig
     * @param {string} key - The string key representing the consumer.
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentWithConfig} The TreatmentWithConfig, the object containing the treatment string and the
     *                                configuration stringified JSON (or null if there was no config for that treatment).
     */
    getTreatmentWithConfig(key: SplitKey, splitName: string, attributes?: Attributes): TreatmentWithConfig,
    /**
     * Returns a Treatments value, which is an object map with the treatments for the given features.
     * @function getTreatments
     * @param {string} key - The string key representing the consumer.
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatments} The treatments object map.
     */
    getTreatments(key: SplitKey, splitNames: string[], attributes?: Attributes): Treatments,
    /**
     * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * @function getTreatmentsWithConfig
     * @param {string} key - The string key representing the consumer.
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects
     */
    getTreatmentsWithConfig(key: SplitKey, splitNames: string[], attributes?: Attributes): TreatmentsWithConfig,
    /**
     * Tracks an event to be fed to the results product on Split Webconsole.
     * @function track
     * @param {SplitKey} key - The key that identifies the entity related to this event.
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {boolean} Whether the event was added to the queue successfully or not.
     */
    track(key: SplitKey, trafficType: string, eventType: string, value?: number, properties?: Properties): boolean,
  }
  /**
   * This represents the interface for the Client instance with asynchronous method calls and server-side SDK, where we don't have only one key.
   * @interface IAsyncClient
   * @extends IBasicClient
   */
  interface IAsyncClientSS extends IBasicClient {
    /**
     * Returns a Treatment value, which will be (or eventually be) the treatment string for the given feature.
     * For usage on NodeJS as we don't have only one key.
     * NOTE: Treatment will be a promise only in async storages, like REDIS.
     * @function getTreatment
     * @param {string} key - The string key representing the consumer.
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatment} Treatment promise which will resolve to the treatment string.
     */
    getTreatment(key: SplitKey, splitName: string, attributes?: Attributes): AsyncTreatment,
    /**
     * Returns a TreatmentWithConfig value, which will be (or eventually be) an object with both treatment and config string for the given feature.
     * For usage on NodeJS as we don't have only one key.
     * NOTE: Treatment will be a promise only in async storages, like REDIS.
     * @function getTreatmentWithConfig
     * @param {string} key - The string key representing the consumer.
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatmentWithConfig} TreatmentWithConfig promise which will resolve to the TreatmentWithConfig object.
     */
    getTreatmentWithConfig(key: SplitKey, splitName: string, attributes?: Attributes): AsyncTreatmentWithConfig,
    /**
     * Returns a Treatments value, which will be (or eventually be) an object map with the treatments for the given features.
     * For usage on NodeJS as we don't have only one key.
     * @function getTreatments
     * @param {string} key - The string key representing the consumer.
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatments} Treatments promise which will resolve to the treatments object map.
     */
    getTreatments(key: SplitKey, splitNames: string[], attributes?: Attributes): AsyncTreatments,
    /**
     * Returns a TreatmentsWithConfig value, which will be (or eventually be) an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * For usage on NodeJS as we don't have only one key.
     * @function getTreatmentsWithConfig
     * @param {string} key - The string key representing the consumer.
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatmentsWithConfig} TreatmentsWithConfig promise which will resolve to the map of TreatmentsWithConfig objects.
     */
    getTreatmentsWithConfig(key: SplitKey, splitNames: string[], attributes?: Attributes): AsyncTreatmentsWithConfig,
    /**
     * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).
     * @function track
     * @param {SplitKey} key - The key that identifies the entity related to this event.
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.
     */
    track(key: SplitKey, trafficType: string, eventType: string, value?: number, properties?: Properties): Promise<boolean>
  }
  /**
   * This represents the interface for the Client instance with attributes binding
   * @interface IClientWithAttributeBinding
   * @extends IBasicClient
   */
  interface IClientWithAttributeBinding extends IBasicClient {
    /**
     * Add an attribute to client's in memory attributes storage.
     *
     * @param {string} attributeName Attribute name
     * @param {AttributeType} attributeValue Attribute value
     * @returns {boolean} true if the attribute was stored and false otherwise
     */
    setAttribute(attributeName: string, attributeValue: AttributeType): boolean,
    /**
     * Returns the attribute with the given key.
     *
     * @param {string} attributeName Attribute name
     * @returns {AttributeType} Attribute with the given key
     */
    getAttribute(attributeName: string): AttributeType,
    /**
     * Removes from client's in memory attributes storage the attribute with the given key.
     *
     * @param {string} attributeName
     * @returns {boolean} true if attribute was removed and false otherwise
     */
    removeAttribute(attributeName: string): boolean,
    /**
     * Add to client's in memory attributes storage the attributes in 'attributes'.
     *
     * @param {Attributes} attributes Object with attributes to store
     * @returns true if attributes were stored an false otherwise
     */
    setAttributes(attributes: Attributes): boolean,
    /**
     * Return all the attributes stored in client's in memory attributes storage.
     *
     * @returns {Attributes} returns all the stored attributes
     */
    getAttributes(): Attributes,
    /**
     * Remove all the stored attributes in the client's in memory attribute storage.
     *
     * @returns {boolean} true if all attribute were removed and false otherwise
     */
    clearAttributes(): boolean
  }
  /**
   * This represents the interface for the Client instance with attributes binding, synchronous method calls, and client-side API, where each client has a key associated.
   * @interface IClientWithKey
   * @extends IClientWithAttributeBinding
   */
  interface IClientWithKey extends IClientWithAttributeBinding {
    /**
     * Returns a Treatment value, which is the treatment string for the given feature.
     * @function getTreatment
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatment} The treatment string.
     */
    getTreatment(splitName: string, attributes?: Attributes): Treatment,
    /**
     * Returns a TreatmentWithConfig value, which is an object with both treatment and config string for the given feature.
     * @function getTreatmentWithConfig
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentWithConfig} The map containing the treatment and the configuration stringified JSON (or null if there was no config for that treatment).
     */
    getTreatmentWithConfig(splitName: string, attributes?: Attributes): TreatmentWithConfig,
    /**
     * Returns a Treatments value, which is an object map with the treatments for the given features.
     * @function getTreatments
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {Treatments} The treatments object map.
     */
    getTreatments(splitNames: string[], attributes?: Attributes): Treatments,
    /**
     * Returns a TreatmentsWithConfig value, which is an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * @function getTreatmentsWithConfig
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentsWithConfig} The map with all the TreatmentWithConfig objects
     */
    getTreatmentsWithConfig(splitNames: string[], attributes?: Attributes): TreatmentsWithConfig,
    /**
     * Tracks an event to be fed to the results product on Split Webconsole.
     * @function track
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {boolean} Whether the event was added to the queue successfully or not.
     */
    track(trafficType: string, eventType: string, value?: number, properties?: Properties): boolean,
  }
  /**
   * This represents the interface for the Client instance with attributes binding, synchronous method calls, and client-side API, where each client has a key associated and optionally a traffic type.
   * @interface IClientWithKeyLegacy
   * @extends IClientWithKey
   */
  interface IClientWithKeyLegacy extends IClientWithKey {
    /**
     * Tracks an event to be fed to the results product on Split Webconsole.
     * @function track
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {boolean} Whether the event was added to the queue successfully or not.
     */
    track(trafficType: string, eventType: string, value?: number, properties?: Properties): boolean,
    /**
     * Tracks an event to be fed to the results product on Split Webconsole.
     * For usage on the Browser if we defined the key and also the trafficType on the settings.
     * @function track
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {boolean} Whether the event was added to the queue successfully or not.
     */
    track(eventType: string, value?: number, properties?: Properties): boolean
  }
  /**
   * This represents the interface for the Client instance with attributes binding, asynchronous method calls, and client-side API, where each client has a key associated.
   * @interface IAsyncClientWithKey
   * @extends IClientWithAttributeBinding
   */
  interface IAsyncClientWithKey extends IClientWithAttributeBinding {
    /**
     * Returns a Treatment value, which will be (or eventually be) the treatment string for the given feature.
     * @function getTreatment
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatment} Treatment promise which will resolve to the treatment string.
     */
    getTreatment(splitName: string, attributes?: Attributes): AsyncTreatment,
    /**
     * Returns a TreatmentWithConfig value, which will be (or eventually be) an object with both treatment and config string for the given feature.
     * @function getTreatmentWithConfig
     * @param {string} splitName - The string that represents the split we wan't to get the treatment.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatmentWithConfig} TreatmentWithConfig promise which will resolve to the TreatmentWithConfig object.
     */
    getTreatmentWithConfig(splitName: string, attributes?: Attributes): AsyncTreatmentWithConfig,
    /**
     * Returns a Treatments value, which will be (or eventually be) an object map with the treatments for the given features.
     * @function getTreatments
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {AsyncTreatments} Treatments promise which will resolve to the treatments object map.
     */
    getTreatments(splitNames: string[], attributes?: Attributes): AsyncTreatments,
    /**
     * Returns a TreatmentsWithConfig value, which will be (or eventually be) an object map with the TreatmentWithConfig (an object with both treatment and config string) for the given features.
     * @function getTreatmentsWithConfig
     * @param {Array<string>} splitNames - An array of the split names we wan't to get the treatments.
     * @param {Attributes=} attributes - An object of type Attributes defining the attributes for the given key.
     * @returns {TreatmentsWithConfig} TreatmentsWithConfig promise which will resolve to the map of TreatmentsWithConfig objects.
     */
    getTreatmentsWithConfig(splitNames: string[], attributes?: Attributes): AsyncTreatmentsWithConfig,
    /**
     * Tracks an event to be fed to the results product on Split Webconsole and returns a promise to signal when the event was successfully queued (or not).
     * @function track
     * @param {string} trafficType - The traffic type of the entity related to this event.
     * @param {string} eventType - The event type corresponding to this event.
     * @param {number=} value - The value of this event.
     * @param {Properties=} properties - The properties of this event. Values can be string, number, boolean or null.
     * @returns {boolean} A promise that resolves to a boolean indicating if the event was added to the queue successfully or not.
     */
    track(trafficType: string, eventType: string, value?: number, properties?: Properties): Promise<boolean>,
  }
  /**
   * Representation of a manager instance with synchronous storage of the SDK.
   * @interface IManager
   * @extends IStatusInterface
   */
  interface IManager extends IStatusInterface {
    /**
     * Get the array of Split names.
     * @function names
     * @returns {SplitNames} The lists of Split names.
     */
    names(): SplitNames;
    /**
     * Get the array of splits data in SplitView format.
     * @function splits
     * @returns {SplitViews} The list of SplitView.
     */
    splits(): SplitViews;
    /**
     * Get the data of a split in SplitView format.
     * @function split
     * @param {string} splitName The name of the split we wan't to get info of.
     * @returns {SplitView | null} The SplitView of the given split or null if the split is not found.
     */
    split(splitName: string): SplitView | null;
  }
  /**
   * Representation of a manager instance with asynchronous storage of the SDK.
   * @interface IAsyncManager
   * @extends IStatusInterface
   */
  interface IAsyncManager extends IStatusInterface {
    /**
     * Get the array of Split names.
     * @function names
     * @returns {SplitNamesAsync} A promise that will resolve to the array of Splitio.SplitNames.
     */
    names(): SplitNamesAsync;
    /**
     * Get the array of splits data in SplitView format.
     * @function splits
     * @returns {SplitViewsAsync} A promise that will resolve to the SplitView list.
     */
    splits(): SplitViewsAsync;
    /**
     * Get the data of a split in SplitView format.
     * @function split
     * @param {string} splitName The name of the split we wan't to get info of.
     * @returns {SplitViewAsync} A promise that will resolve to the SplitView value or null if the split is not found.
     */
    split(splitName: string): SplitViewAsync;
  }
}
